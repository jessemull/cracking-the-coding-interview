How do you declare an object or class in Kotlin?
1. Use the keyword class and give it a name.

class Car {

}

2. Add properties to the class.

class Car {
  var name = ""
  var model = ""
  var colors = ""
  var doors = 0
}

3. Add functions to the class.

class Car {
  var name = ""
  var model = ""
  var colors = ""
  var doors = 0

  fun start() {
    println("Car $name $model is moving...")
  }

  fun stop() {
    println("Car $name $model has stopped moving...")
  }
}

4. To create a new car instantiate it. Do not use the new keyword.

val car = Car()

5. Access or set the properties using dot notation. These properties are specific to the instance of the class.

val car = Car()
car.name = "Mazda"
car.model = "CX5"
car.color = "Green"
car.doors = 4
println(car.name) // Mazda

6. Call functions on the instance using dot notation.

val car = Car()
car.start()
car.stop()

7. Remember that an instance of an object is a distinct slice of memory with its owns properties.

How do constructors work in Kotlin?
1. Use a constructor to set up properties on instantiation. The constructor is called when the object is created.
2. Pass arguments to the class between parens.

class Car(name: String, color: String, model: String, doors: Int) {
  var name = name
  var model = model
  var colors = color
  var doors = doors

  fun start() {
    println("Car $name $model is moving...")
  }

  fun stop() {
    println("Car $name $model has stopped moving...")
  }
}

3. You can declare properties directly into the constructor with Kotlin to not reassign them.

class Car(var name: String, var color: String, var model: String, var doors: Int) {
  fun start() {
    println("Car $name $model is moving...")
  }

  fun stop() {
    println("Car $name $model has stopped moving...")
  }
}

4. May still need to assign the values in the constructor because may require validation or default behavior or calculations. If you need to do work before assingment you will not be able to include in the constructor.

class Car(name: String, var color: String, var model: String, var doors: Int) {
  var name = name.trim()

  fun start() {
    println("Car $name $model is moving...")
  }

  fun stop() {
    println("Car $name $model has stopped moving...")
  }
}

5. If you need to handle complex logic that includes more than one line of code you can do that inside of an initializer block. Use the this keyword in the init block to refer to the property.

class User(name: String, var lastName: String, var age: Int) {
  var name: String

  init {
      if (name.lowercase().startsWith('a')) {
        this.name = name
      } else {
        this.name = "John Doe"
      }
  }
}

What are secondary constructors in Kotlin?
1. In Kotlin you can create more than one constructor.
2. This is used to create default values to some of the primary constructor arguments if they are undefined.
3. You can use more than one secondary constructor.
4. You can execute more code in a code block but you have to call this first.

class Person(var name: String, var lastName: String, var age: Int) {
    constructor(name: String): this(name, "Doe", 0)
    constructor(name: String, lastName: String): this(name, lastName, 0) {
      println("There was no age supplied assigning zero.")
    }
}

How can you set default values and used name args for properties in the primary constructor?
1. You can just use the equals sign to set default values in the constructor instead of using secondary constructors.

class DefaultPerson(var name: String = "John", var lastName: String = "Doe", var age: Int = 0) {}

2. You can use named argument just like in functions in the constructor.

class Person(var name: String = "John", var lastName: String = "Doe", var age: Int = 0) {}
val person = Person(name = "Jesse", lastName = "Mull")

How do you create getters and setters in Kotlin?
1. Getters and setters are auto-generated by default. 
2. If you use the dot notation to access a property it is actually using a getter.
3. If you use the dot notation to set a property it is actually using the setter.
4. In Kotlin properties are never accessed directly.
5. You can override the default getter or setter. This is what the default getter and setter look like.

class Person(name: String = "John", var lastName: String = "Doe", var age: Int = 0) {
  var name = name
  get() {
    return field
  }
  set(value) {
      field = value
  }
}

6. You can update the code to override them.

class Person(name: String = "John", var lastName: String = "Doe", var age: Int = 0) {
  var name = name
  get() {
    return "First name is: " + field
  }
  set(value) {
      field = value.lowercase()
  }
}

7. Note that Kotlin uses the field keyword in the setter to avoid infinite recursive calls setting the field.

How does the lateinit keyword work in Kotlin?
1. Use lateinit keyword before proeprty declaration to assign a value to a property post initialization.

class LateInitPerson(var name: String = "John", var lastName: String = "Doe", var age: Int = 0) {
  lateinit var favoriteMovie: String
}

2. If you try to access a lateinit property before it has been initialized Kotlin throws an error explaining that lateinit value wasn't initialized.
3. The UninitiazliedPropertyAccessException is better than getting a null pointer because it occurs at compile time and not run time.
4. You can only use lateinit on classes like String and not on primitive types.

How do companion objects work in Kotlin?
1. Can create a companion object inside of a class in order to be able to call functions or access properties without instantiation.
2. These are called class functions or properties.

class Companion() {
    companion object {
        val MAX = 1000
        fun sum(a: Int, b: Int): Int {
            return a + b
        }
    }
}

val sum = Companion.sum(1, 1) // 2
println(Companion.MAX) // 1000

How do singletons work in Kotlin?
1. A singleton is a design pattern where you want only one instance of a particular object.
2. The singleton might be available globally throughout your project.
3. An example of a singleton instance would be a database connection.
4. This is the old way of creating a singleton.

class Connection private constructor() {
  companion object {
      private var instance: Database? = null
      fun getInstance(): Database {
          if (instance == null) {
              instance = Database()
          }
          return instance
      }
  }
}

val connection = Connection.getInstance()

5. This is the new way to create a singleton instance using the object keyword. It can have an init block.

object Connection {
    private var Database: String? = null
    init {
        println("Initializing...")
    }
    fun getInstance(): String {
        if (this.Database == null) {
            this.Database = "Database"
        }
        return this.Database!!
    }
}

val connection = Connection.getInstance()

How does lazy initialization work in Kotlin?
1. You can use the by and lazy keywords to lazily initialize objects.
2. The object remains uninitialized until it is used.

class User(firstName: String) {
  init {
    println("Initializing user...")
  }
}

val lazyUser by lazy {
    User("Jesse") // No println statement here.
}

println(lazyUser.firstName) // Now we see the println inside the init block.

What are enum classes in Kotlin?
1. Used to create a set of constants.
2. They are more powerful because they can have properties and functions.
3. Often used in conditionals or for comparison/equality.
4. To create an enum use the enum keyword before the class declaration.

enum class Directions {
  NORTH,
  SOUTH,
  EAST,
  WEST
}

5. To access the values just use dot notation.

Directions.NORTH

6. In Kotlin there is no need to assign a string value to the enum value. It is implicit.
7. You can add properties in the constructor and then they need to be defined for each enum value.

enum class Directions(var label: String, var distance: Int) {
    NORTH("North", 10),
    SOUTH("South", 50),
    EAST("East", 100),
    WEST("West", 500)
}

8. To loop through enum values you can call the values function on the enum class. Note that it prints out the value and not the associated properties.

for (direction in Directions.values()) {
  println(direction) // NORTH/SOUTH/EAST/WEST
}

9. You can access the enum properties using dot notation on the value.

println(Directions.NORTH.direction) // North
println(Directions.NORTH.distance) // 10

10. Can still loop over the values the same way.

for (direction in Directions.values()) {
    println(direction) // e.g. NORTH
    println(direction.label) // e.g. North
    println(direction.distance) // e.g. 10
}

11. You can even add functions to the enum. Access the enum properties directly.

enum class Directions(var label: String, var distance: Int) {
    NORTH("North", 10),
    SOUTH("South", 50),
    EAST("East", 100),
    WEST("West", 500)

    fun print() {
      println(label)
      println("Label: $label Distance: $distance")
    }
}

How do inner classes in Kotlin work?
1. You can create an inner class inside of another class that is closely associated with it. Use the keyword inner.

class ListView(var items: Array<String>) {
  inner class ListViewItem {

  }
}

2. Inner classes have access to the properties of the outer class.

class ListView(var items: Array<String>) {
  inner class ListViewItem {
    fun position(index: Int) {
      println(items[index])
    }
  }
}

3. To access the inner class you use dot notation and then call the constructor.

val inner = ListView(arrayOf("One", "Two", "Three"))
inner.ListViewItem().position(0)

How does inheritance work in Kotlin?
1. If you want another object to have access to a set of parent functions and properties you can use inheritance.
2. Carefully designing parent-child relationships can lead to code reuse and code reusability.
3. Classes that are heritable must be marked with the open keyword.
4. Extend a class by using a colon followed by the class name.
5. The extended class constructor must be invoked with the appropriate arguments.
6. The class inheriting must add the properties passed to the extended classes constructor.
7. The arguments passed to the object's constructor are automatically passed to the base class constructor.
8. To override a function we have to add the open keyword to the function declaration in the base class and the override keyword to the function in the inheriting class.
9. The super keyword can be used to access a property or function in the base class.

open class Vehicle(var name: String, var speed: Int) {
    open fun move() {
        println("Vehicle $name is moving...")
    }

    fun stop() {
        println("Vehicle $name is moving...")
    }
}

class Boat(name: String, speed: Int, var engines: Int, var sails: Int): Vehicle(name, speed) {
    override fun move() {
        super.move()
        println("Boat $name is moving...")
    }
}

class Plane(name: String, speed: Int, var wings: Int, var isJet: Boolean): Vehicle(name, speed) {
    override fun move() {
        println("Plane $name is moving...")
    }
}

What is a sealed class in Kotlin?
1. Similar to an enum class but with more functionality.
2. Declare a sealed class by using the sealed keyword.
3. Add inner classes that extend the outer class.
4. When used in a when statement (switch block) it is required to exhaust all of the inner class members.
5. Sealed classes provide controlled inheritance of the class structure.
6. Useful for when you have a predefined hierarchy of classes.
7. Useful for when statements and switch blocks where you need to handle all cases.
8. Useful for when you want to enforce API usage in a certain predefined way.
9. Often used for creating sets of errors.

sealed class Result(var message: String) {
    class Success(message: String): Result(message)
    class Error(message: String): Result(message)

    fun printMessage() {
        println("Result - $message")
    }
}

fun getResult(result: Result) {
    when(result) {
        is Result.Success -> result.printMessage()
        is Result.Error -> result.printMessage()
    }
}

How do abstract classes work in Kotlin?
1. 